Index: services/mesh.c
===================================================================
--- services/mesh.c	(revision 4391)
+++ services/mesh.c	(working copy)
@@ -974,7 +974,10 @@
 	else	secure = 0;
 	if(!rep && rcode == LDNS_RCODE_NOERROR)
 		rcode = LDNS_RCODE_SERVFAIL;
-	if(!rcode && (rep->security == sec_status_bogus ||
-		rep->security == sec_status_secure_sentinel_fail)) {
+	/* internetnl patch:
+	 * Write to reason even if not bogus. Will pass the DS unsupported value.
+	 * reason ends up as the why_bogus value . */
+	if(!rcode) /*&& (rep->security == sec_status_bogus ||
+		rep->security == sec_status_secure_sentinel_fail))*/ {
 		if(!(reason = errinf_to_str_bogus(&m->s)))
 			rcode = LDNS_RCODE_SERVFAIL;
 	}
Index: validator/validator.c
===================================================================
--- validator/validator.c	(revision 4391)
+++ validator/validator.c	(working copy)
@@ -2590,6 +2590,10 @@
 			*ke = key_entry_create_null(qstate->region, 
 				qinfo->qname, qinfo->qname_len, qinfo->qclass, 
 				ub_packed_rrset_ttl(ds), *qstate->env->now);
+			/* internetnl patch:
+			 * Write custom string to qstate->errinf. Will eventually end up
+			 * to the why_bogus variable. */
+			errinf(qstate, "internetnl - DS unsupported.");
 			return (*ke) != NULL;
 		}
 
